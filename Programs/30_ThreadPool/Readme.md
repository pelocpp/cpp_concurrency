# Realisierung eines Thread Pools

[Zurück](../../Readme.md)

---

## Verwendete Werkzeuge

<ins>Klassen</ins>:

  * Klasse `std::atomic_bool`
  * Klasse `std::function`
  * Klasse `std::thread`
  * Eine Klasse für eine *ThreadsafeQueue*

<ins>Funktionen</ins>:

  * Funktion `std::thread::hardware_concurrency`

---

## Allgemeines

Ein *Thread Pool* ermöglicht es, Threads wiederzuverwenden.
Auf diese Weise wird verhindert, dass zur Laufzeit neue Threads erstellt werden müssen.
Das Erstellen neuer Threads ist zeit- und ressourcenintensiv. 

Wir stellen in diesem Projekt einige Thread Pool Realisierungen vor.

---

## Eine sehr einfache Thread Pool Realisierung

> Literaturhinweis: Diese Realisierung stammt aus dem Buch &bdquo;Concurrency in Action - 2nd Edition&rdquo; von
Anthony Williams, Kapitel 9.1.

In dieser Realisierung besteht der Thread Pool aus einer festen Anzahl von Worker Threads.
Typischerweise wird diese Anzahl von der Funktion `std::thread::hardware_concurrency()` festgelegt.

Steht eine Aufgabe (*Task*) zur Ausführung an, gibt es am Thread Pool eine Methode (hier: `submit`),
die diese Funktion (*Callable*) in die Warteschlange aller noch ausstehenden Tasks am Ende hinzufügt.

Jeder Worker Thread entnimmt, wenn er nichts zu tun hat, eine Task vom Anfang dieser Warteschlange und führt die Funktion aus.
Nach Ausführung der Funktion entnimmt der Worker Thread die nächste Task aus der Warteschlange
oder er begibt sich in einen *Idle*-Zustand, wenn die Warteschlange leer ist.

In der aktuellen Realisierung haben die Tasks in der Warteschlange alle den Rückgabetyp `void`,
es gibt also keine direkte Möglichkeit, ein Ergebnis zurückzuliefern.

Auch gibt es keine Möglichkeit, auf das Ende der Ausführung einer Task zu warten.

Der größte Nachteil in dieser ersten Realisierung besteht jedoch darin,
dass die Worker Threads, die sich im *Idle*-Zustand befinden, aktiv den Zustand der Warteschlange überprüfen.
Wir haben es also mit dem so genannten &bdquo;*Busy Polling*&rdquo; zu tun.
Diesen Nachteil werden wir in einer nachfolgenden Variation beheben.

---

### Weitere Hinweise zur Realisierung

Die `worker_thread`-Funktion selbst ist recht einfach:
Sie befindet sich in einer Wiederholungsschleife und wartet, bis das `m_done`-Flag gesetzt ist,
entnimmt Tasks aus der Warteschlange und führt sie in der Zwischenzeit aus:


```cpp
01: void ThreadPool::worker_thread()
02: {
03:     while (!m_done)
04:     {
05:         std::function<void()> task{};
06: 
07:         if (m_workQueue.tryPop(task))
08:         {
09:             task();
10:         }
11:         else
12:         {
13:             std::this_thread::yield();
14:         }
15:     }
16: }
```

Die Ursache des *Busy Pollings* ist in der Methode `tryPop` verborgen:

```cpp
01: bool tryPop(T& value)
02: {
03:     std::lock_guard<std::mutex> lock{ m_mutex };
04:     if (m_data.empty()) {
05:         return false;
06:     }
07: 
08:     value = m_data.front();
09:     m_data.pop();
10:     return true;
11: }
```

Die `tryPop`-Methode verwendet keinerlei Koordinierungsmechanismen (wie z.B. ein `std::condition_variable`-Objekt),
um mit entsprechenden `wait`- und `notify_one`-Aufrufen das *Busy Polling* zu umgehen.

Wenn sich keine Tasks in der Warteschlange befinden, ruft die Funktion `std::this_thread::yield()` auf,
um zumindest eine kleine Pause einzulegen und einem anderen Thread die Möglichkeit zu geben,
etwas Arbeit in die Warteschlange zu stellen, bevor er beim nächsten Mal wieder versucht, etwas zu entnehmen.

Beachten Sie, dass die Reihenfolge der Deklarationen der Instanzvariablen von Klasse `ThreadPool` wichtig ist:

```cpp
01: class ThreadPool
02: {
03: private:
04:     std::atomic_bool                        m_done;
05:     ThreadsafeQueue<std::function<void()>>  m_workQueue;
06:     std::vector<std::thread>                m_threads;
07:     JoinThreads                             m_joiner;
08: 
09: ...
```

Sowohl das `m_done`-Flag als auch das Objekt `m_workQueue` müssen vor dem Vektor der Threads `m_threads` deklariert werden,
der wiederum vor dem Objekt des Typs `JoinThreads` deklariert werden muss:

Dadurch wird sichergestellt, dass die Instanzvariablen in der richtigen Reihenfolge zerstört werden.
Das `m_joiner`-Objekt ist in seinem Destruktor dafür verantwortlich, auf das Ende aller Threads zu warten.
Erst danach kann man die beiden Objekte mit den Threads und den Tasks sicher zerstören,
wenn alle Worker Threads gestoppt worden sind.

---

### Ein Blick auf die Ausführung


Wir reihen 10 Tasks in ein `ThreadPool`-Objekt ein:

```cpp
01: auto callable = [] ()
02: {
03:     std::stringstream ss;
04:     ss << "Thread " << std::setw(4) << std::setfill('0')
05:         << std::uppercase << std::hex << std::this_thread::get_id();
06: 
07:     std::this_thread::sleep_for(std::chrono::milliseconds{ 100 });
08: };
```

Die Ausführung des Thread Pools in der Konsole sieht in etwa so aus:

Zu Beginn:

```[1]:    push_back of next worker_thread function ...
[1]:    push_back of next worker_thread function ...
[1]:    push_back of next worker_thread function ...
[1]:    push_back of next worker_thread function ...
[1]:    push_back of next worker_thread function ...
[1]:    push_back of next worker_thread function ...
[1]:    push_back of next worker_thread function ...
[1]:    push_back of next worker_thread function ...
[3]:    > worker_thread ...
[2]:    > worker_thread ...
[3]:    std::this_thread::yield ...
[2]:    std::this_thread::yield ...
[3]:    std::this_thread::yield ...
[4]:    > worker_thread ...
[2]:    std::this_thread::yield ...
[4]:    std::this_thread::yield ...
[7]:    > worker_thread ...
[9]:    > worker_thread ...
[7]:    std::this_thread::yield ...
[6]:    > worker_thread ...
[7]:    std::this_thread::yield ...
[6]:    std::this_thread::yield ...
[3]:    std::this_thread::yield ...
[6]:    std::this_thread::yield ...
[3]:    std::this_thread::yield ...
[6]:    std::this_thread::yield ...
[6]:    std::this_thread::yield ...
[5]:    > worker_thread ...
[1]:    push_back of next worker_thread function ...
[2]:    std::this_thread::yield ...
[7]:    std::this_thread::yield ...
```

Wir erkennen jetzt schon die vielen Aufrufe von `std::this_thread::yield`.

Wenn keine neuen Aufgaben in den Pool hinzugefügt werden, sieht es so aus:

```
[4]:    std::this_thread::yield ...
[7]:    std::this_thread::yield ...
[8]:    std::this_thread::yield ...
[6]:    std::this_thread::yield ...
[3]:    std::this_thread::yield ...
[6]:    std::this_thread::yield ...
[4]:    std::this_thread::yield ...
[4]:    std::this_thread::yield ...
[7]:    std::this_thread::yield ...
[8]:    std::this_thread::yield ...
[9]:    std::this_thread::yield ...
[3]:    std::this_thread::yield ...
[9]:    std::this_thread::yield ...
[9]:    std::this_thread::yield ...
[4]:    std::this_thread::yield ...
[7]:    std::this_thread::yield ...
[8]:    std::this_thread::yield ...
[3]:    std::this_thread::yield ...
[8]:    std::this_thread::yield ...
[9]:    std::this_thread::yield ...
[4]:    std::this_thread::yield ...
[4]:    std::this_thread::yield ...
```

Sind Tätigkeiten zu Ende, finden wir deren Ausgaben vor:

```
[8]:    std::this_thread::yield ...
[7]:    std::this_thread::yield ...
[6]:    std::this_thread::yield ...
[7]:    std::this_thread::yield ...
[3]:    std::this_thread::yield ...
[11]:   ###  > Thread 22868
[10]:   ###  > Thread 21496
[11]:   std::this_thread::yield ...
[8]:    std::this_thread::yield ...
[11]:   std::this_thread::yield ...
[6]:    std::this_thread::yield ...
[6]:    std::this_thread::yield ...
[3]:    std::this_thread::yield ...
[6]:    std::this_thread::yield ...
[10]:   std::this_thread::yield ...
[2]:    ###  > Thread 22068
[2]:    std::this_thread::yield ...
[9]:    std::this_thread::yield ...
[2]:    std::this_thread::yield ...
[12]:   ###  > Thread 17956
[11]:   std::this_thread::yield ...
[8]:    std::this_thread::yield ...
[11]:   std::this_thread::yield ...
```

Am Ende sieht es so aus:

```
[7]:    std::this_thread::yield ...
[6]:    std::this_thread::yield ...
[9]:    std::this_thread::yield ...
[9]:    < worker_thread ...
[16]:   std::this_thread::yield ...
[13]:   std::this_thread::yield ...
[12]:   std::this_thread::yield ...
[3]:    std::this_thread::yield ...
[12]:   < worker_thread ...
[8]:    std::this_thread::yield ...
[17]:   std::this_thread::yield ...
[4]:    std::this_thread::yield ...
[1]:    > ~JoinThreads ...
[4]:    < worker_thread ...
[6]:    < worker_thread ...
[16]:   < worker_thread ...
[13]:   < worker_thread ...
[15]:   < worker_thread ...
[5]:    < worker_thread ...
[14]:   < worker_thread ...
[2]:    < worker_thread ...
[10]:   < worker_thread ...
[3]:    < worker_thread ...
[11]:   std::this_thread::yield ...
[11]:   < worker_thread ...
[8]:    < worker_thread ...
[17]:   < worker_thread ...
[7]:    < worker_thread ...
[1]:    < ~JoinThreads ...
```

---

## Literaturhinweise

Das erste Beispiel ist aus dem Buch &bdquo;Concurrency in Action - 2nd Edition&rdquo; von
Anthony Williams, Kapitel 9.1, entnommen.

---


[Zurück](../../Readme.md)

---

